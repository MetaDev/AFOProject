import numpy as np
def clearAll():
    doc = App.ActiveDocument
    for obj in doc.Objects:
        doc.removeObject(obj.Label)
def vectorToNPArr(v):
    return np.array([v.x,v.y,v.z])
#extract the vertices per index in a list of faces, used for uv calculation
def getVertexesFromFaces(faces,i):
    return np.array([[f.Vertexes[i].Point.x,f.Vertexes[i].Point.y,f.Vertexes[i].Point.z] for f in faces])
#return index of closest nodes and their distance
def getIndexAndDistancefromClosestNodesToPoint(facesNodesVertexes,face_point, n_nodes):
    distances  = [np.linalg.norm(v-face_point) for v in facesNodesVertexes]
    print(distances.count)    
#list of n closest distances with index
    return sorted(enumerate(distances),key=lambda id: id[1])[:n_nodes]
	

##https://medium.com/@daviddelaiglesiacastro/3d-point-cloud-generation-from-3d-triangular-mesh-bbb602ecf238
def GetRandomPointsOnPart(part, n_samples):	
    faces= part.Faces
    totalArea= sum(face.Area for face in faces)
    areas = np.array([ face.Area for face in faces])
    probabilities= areas/sum(areas)
    weighted_random_faces_index = np.random.choice(range(len(areas)),size=n_samples,p=probabilities)
    
    weighted_random_faces = [part.Faces[i] for i in weighted_random_faces_index]
    print(weighted_random_faces)    
#use UV mapping to calculate random point in face (triangle)
    v1_xyz = getVertexesFromFaces(weighted_random_faces,0)
    v2_xyz = getVertexesFromFaces(weighted_random_faces,1)
    v3_xyz = getVertexesFromFaces(weighted_random_faces,2)
    u=np.random.rand(n_samples,1)
    v=np.random.rand(n_samples,1)
    is_a_problem = u+v >1
    u[is_a_problem]= 1- u[is_a_problem]
    v[is_a_problem] = 1- v[is_a_problem]
    w=1- (u+v)   
    result_xyz = ( v1_xyz *u) + (v2_xyz  *v) + (w *v3_xyz )
    
    return result_xyz, weighted_random_faces

def getRandomStrainsOnPart(part, femM_obj ,femmesh_result_object,n_samples):
    #np array [n_sample,3]
    random_vertexes_in_face,random_faces = GetRandomPointsOnPart(part, n_samples)
    
    #get node vertices in faces
    print(random_faces)
    print([len(femM_obj.FemMesh.getNodesByFace(f)) for f in random_faces])
    vertex_of_nodes_in_face = [[vectorToNPArr(fmObj.FemMesh.getNodeById(i)) for i in femM_obj.FemMesh.getNodesByFace(f)] for f in random_faces] 
    print([len(v) for v in vertex_of_nodes_in_face])
    #calculate the n closest nodes to a point and the respective distance for later weighted sum
    ind_distances = [getIndexAndDistancefromClosestNodesToPoint(vns,rv,4) for rv,vns in zip(random_vertexes_in_face,vertex_of_nodes_in_face)]
    #implementation choice is idw but rbf is also possible (https://stackoverflow.com/questions/3104781/inverse-distance-weighted-idw-interpolation-with-python)
	#inverse weighted sum of strain vectors
    weighted_strains=[]
    print(ind_distances)
    for ids in ind_distances:
        #convert to full np array
        ids=np.array(ids)
        print(ids)
        vs = np.array([vectorToNPArr(femmesh_result_object.StrainVectors[int(id[0])]) for id in ids])
        #calc weights
        weights = 1.0 /ids[:,1]
        weights /= weights.sum(axis=0)
        weighted_strains.append(np.dot(weights.T,vs))
    return weighted_strains
          
clearAll()
doc = App.ActiveDocument

import Part, Fem, FemGmshTools
import ObjectsFem
# some geometry
box = Part.makeBox(1000,1000,8000)
box_obj = App.ActiveDocument.addObject('Part::Box', 'Box')


## change box and remesh, we do not need a new instance of gmsh_mesh class
#box_obj.Length = 4
#box_obj.Height = 20
#error = gmsh_mesh.create_mesh()
#print error
#App.ActiveDocument.recompute()
## change mesh params and remesh, we need a new instance of gmsh_mesh class
#femmesh_obj_gmsh.CharacteristicLengthMax = 1
#gmsh_mesh = FemGmshTools.FemGmshTools(femmesh_obj_gmsh)
#error = gmsh_mesh.create_mesh()
#print error
#App.ActiveDocument.recompute()


# analysis
analysis_object = ObjectsFem.makeAnalysis("Analysis")
# solver
solver_object = ObjectsFem.makeSolverCalculix('CalculiX')
solver_object.AnalysisType = 'static' 
solver_object.GeometricalNonlinearity = 'linear'
#solver_object.SteadyState = True
#solver_object.Accurency = 0.01
#solver_object.EigenmodeNumber = 1
solver_object.ThermoMechSteadyState = True
solver_object.MatrixSolverType = 'default'
solver_object.IterationsControlParameterTimeUse = False
doc.Analysis.Member = doc.Analysis.Member + [solver_object]

# force_constraint
force_constraint = doc.addObject("Fem::ConstraintForce", "FemConstraintForce")
force_constraint.References = [(doc.Box, "Face2")]
force_constraint.Force = 9000.0
force_constraint.Direction = (doc.Box, ["Edge1"])

force_constraint.Reversed = False
doc.Analysis.Member = doc.Analysis.Member + [force_constraint]

# fixed_constraint
fixed_constraint = doc.addObject("Fem::ConstraintFixed", "FemConstraintFixed")
fixed_constraint.References = [(doc.Box, "Face1")]
doc.Analysis.Member = doc.Analysis.Member + [fixed_constraint]


#import MechanicalMaterial
material_object = ObjectsFem.makeMaterialSolid("SolidMaterial")
mat = material_object.Material
mat['Name'] = "Steel-Generic"
mat['YoungsModulus'] = "210000 MPa"
mat['PoissonRatio'] = "0.30"
mat['Density'] = "7900 kg/m^3"
material_object.Material = mat
doc.Analysis.Member = doc.Analysis.Member + [material_object]

# make an initial FEM mesh
femmesh_obj_gmsh = ObjectsFem.makeMeshGmsh('MyGMSHMeshObj')
femmesh_obj_gmsh.Part = box_obj
App.ActiveDocument.recompute()
gmsh_mesh = FemGmshTools.FemGmshTools(femmesh_obj_gmsh)
error = gmsh_mesh.create_mesh()
print error
App.ActiveDocument.recompute()

# mesh
doc.Analysis.Member = doc.Analysis.Member + [doc.MyGMSHMeshObj]

# recompute doc
doc.recompute()

import FemGui
FemGui.setActiveAnalysis(FreeCAD.ActiveDocument.Analysis)
import FemToolsCcx
fea = FemToolsCcx.FemToolsCcx()
fea.update_objects()
fea.check_prerequisites() # a string is returned, the string should be empty
fea.reset_all()
fea.run()

fea.load_results()
	
# run the analysis
for m in analysis_object.Member:
    if m.isDerivedFrom('Fem::FemResultObject'):
        result_object = m
        break
femmesh_obj_gmsh.ViewObject.setNodeDisplacementByVectors(result_object.NodeNumbers, result_object.DisplacementVectors)
femmesh_obj_gmsh.ViewObject.applyDisplacement(10)
for m in FreeCAD.ActiveDocument.Objects:
    if m.isDerivedFrom('Fem::FemMeshObject'):
        fmObj = m
        break

# I don't know how the nodes in a mesh are distributed, for a uniform sampling I sample the mesh and not the nodesp


#TODO figure out to get the triangles from the femmesh not the part
print([fmObj.FemMesh.getNodesByFace(f) for f in box.Faces])
print(dir(fmObj.FemMesh))
#print(getRandomStrainsOnPart(box,fmObj,result_object,10))
#print(dir(result_object))
#print(fmObj.FemMesh.getNodeById(1) )
#print(dir(fmObj.FemMesh.Faces[0]))
##print(dir(box.Faces[0]))
##print((sample_areas (box,12)))
#print(dir(fmObj.FemMesh.getNodesByFace(box.Faces[0])[0]))
#print strain vectors, their position? -> vector is ordered by node and node has a vertex (3D position)